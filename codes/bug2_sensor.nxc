/*******************************
* BUG2 Viendo el objeto
* por la izquierda
********************************/

/* PUERTOS SENSORES */
#define us_port_izquierda IN_1
#define us_port_frente IN_2

/* PUERTOS MOTORES */
#define MOTOR_DERECHA OUT_C
#define MOTOR_IZQUIERDA OUT_A

/* DEBUG PARA SOLO VER SENSORES  */
//#define ACTIVAR_MOTORES

/* DISTANCIA A VER UN OBSTACULO */
#define THRESHOLD 30

///////USADOS PARA LA ESTIMACION DE ATAN /////////////////////
#define A0 1.5707288
#define A1 0.2121144
#define A2 0.074261
#define A3 0.0187293
//////////////////////////////////////////////////////////////

#define SpeedSlow 0   // VELOCIDAD MINIMA
#define SpeedFast 60  // VELOCIDAD MAXIMA

///////CONSTANTES/////////////////////////////////////////////
#define k1 0.5
#define k2 1
//////////////////////////////////////////////////////////////

int SD;               // Valor obtenido tachometer MotorDerecho
int SI;               // Valor obtenido tachometer MotorIzquierdo

float pi = 3.1416;

float x = 0.0;        //distancia recorrido eje x
float y = 0.0;        //distancia recorrido eje y

float theta = 0.0;   //Angulo inclinacion theta

float ttemp;          //theta

void show_text(float x,float y,float ttemp){
     TextOut(0,LCD_LINE4,"X:"  + NumToStr(x) + "    "); //x LPOS el valor se actualiza
     TextOut(0,LCD_LINE5,"Y:"  + NumToStr(y) + "     "); //y RPOS el valor se actualiza
     TextOut(0,LCD_LINE6,"O:" + NumToStr(ttemp) + "       ");     
}

/**********************************************
 * Funcion para pasar de grados a radiales
 *********************************************/
float grados_radianes(int grados){
      return (grados * (pi/180.0));
}

//TODO: PONER TODAS LAS VARIABLES DENTRO DEL TASK DEL ODOMETRO
//TODO: INCLUIR SHOW_TEXT (SI APLICA)
/**********************************************
 * TASK ODOMETRIA
 *********************************************/
task odometria(){

     
     int LPOS = 0; //Posicion MotorA
     int RPOS = 0; //Posicion MotorC

     int umbral = 5;
     
     int Rprev;    //Posicion MotorC Previa
     int Lprev;    //Posicion MotorA Previa

     float DD; //Distancia recorrida del punto medio robot
     float DL; //Distancia recorrida llanta izquierda
     float DW; //
     float DR; //Distancia recorrida llanta derecha

     float radio = 2.85;      //radio ruedas
     float longitud = 16.2;  //distancia entre ruedas

     while(true){

	LPOS = MotorRotationCount(MOTOR_IZQUIERDA);
	RPOS = MotorRotationCount(MOTOR_DERECHA);
	
	float xx, yy;
	
	DR = RPOS - Rprev; //calcular delta derecha
     	DL = LPOS - Lprev; //calcular delta izquierda

	// Si sobrepasa un valor considerable continuar con el programa
     	if (abs(DR) < umbral && abs(DL) < umbral) continue;

	// Calcular distancias Derecha-Izquierda
     	DR = radio * grados_radianes(DR);
     	DL = radio * grados_radianes(DL);

	// DISTANCIA DEL VEHICULO POSICION MEDIA
	DD = ((DR+DL)/2.0);

	//
     	DW = (DR-DL)/longitud;

	//theta temporal
	ttemp = theta * (180.0/pi);
	//DD=10.0;
	
	//x
	//x = x + ((DD * Cos(ttemp))/100);
	// x = x + ((DD * Cos(ttemp))/100.0);
	xx=Cos(ttemp) / 100.0;
	xx=DD*xx;
	xx=x+xx;
	x = xx;
	
	yy =  Sin(ttemp)/100.0;
	yy=DD*yy;
	yy=y+yy;
	y = yy;
	//y = y + ((DD * Sin(theta))/100);
	//y = y + ((DD * Sin(ttemp))/100);

	theta = theta + DW;

	//Hacer validacion
	////////////////////////////////////////////////////////////
	//Si theta es mayor a pi -> restarle 2pi
	//Si theta es menor a -pi -> sumarle 2pi
	////////////////////////////////////////////////////////////

	Lprev = LPOS;
     	Rprev = RPOS;
	Wait(50);

	//show_text(x,y,ttemp);
	
     } 
}

/// probar si es simetrica
/// si no es simetrica no puedo alimentarlo con valores negativos
/// hacerlo como asin(-0.7) -> temp -(-0.7) -> aprox 
//resultado en radianes
float asin(float x){

      float xtemp;
      if(x<0){
	xtemp = -x;
      }else{
        xtemp = x;
      }

      float rr;
      float rr2;
      float resultado;
      
      rr2 = 1 - xtemp;
      //Validar que no truene
      rr2 = sqrt(rr2);
      rr = (A0 +(-A1+(A2-A3*xtemp)*xtemp)*xtemp);

      resultado = pi/2 - (rr2*rr);

      if(x<0){
         resultado = -resultado;
      }

      return resultado;
      
}

int xf = 150;
int yf = 150;

long power(float a , float b) {  
    long pow = 1;  

    for (int i = 0; i < b; i++) {  
        pow = pow * a; 
    }
    
    return pow;
}

float VR[][] = {
      	     {0,-10,-10,-10},
      	     {0,-10,-10,-10},
      	     {0, 10, 20, 30},
      	     {0, 10, 10, 10},
      	     {0, 10, 10, 10}
      	  };

float VL[][] = {
      	     {0, 10, 10, 10},
      	     {0, 10, 10, 10},
      	     {0, 10, 20, 30},
      	     {0,-10,-10,-10},
      	     {0,-10,-10,-10}
      	  };

float MA[4];
void getDistance(float a){

     float z=0;
     float c=0;
     float l=0;
     float ml=0;

     if(a<10){
	z = 1 - (a/10);
	c = a/10;
	l = 0; ml = 0;
     }else if(a<50){
	c=1-((a-10)/40);
	l = ((a-10)/40);
	ml = 0; z=0;
     }else if(a<100){
     	z = 0; c = 0;
	l = (1-((a-50)/50));
	ml = ((a-50)/50);
     }else{
	z = 0;c = 0;l = 0;ml = 1;
     }

     MA[0] = z;
     MA[1] = c;
     MA[2] = l;
     MA[3] = ml;
}

float MAlpha[5];
void getAlpha(float alpha){

     
     float DD = -pi;
     float  D = -(pi/4);
     float  Z = 0;
     float  I = (pi/4);
     float DI = pi;
     
     
     float MDD = 0;
     float  MD = 0;
     float  MZ = 0;
     float  MI = 0;
     float MDI = 0;
     
     if(alpha < D){
     	MD = ((alpha-DD)/(D-DD));
	MDD = 1-MD;
	MZ=0;MI=0;MDI=0;
     }else if(alpha < Z){
     	MZ = ((alpha-D)/(Z-D));
	MD = 1-MZ;
	MDD=0;MI=0;MDI=0;
     }else if(alpha < I){
     	MI = ((alpha-Z)/(I-Z));
	MZ = 1-MI;
	MDD=0;MD=0;MDI=0;
     }else{
        MDI = ((alpha-I)/(DI-I));
	MI = 1-MDI;
	MDD=0;MD=0;MZ=0;
     }

     MAlpha[0] = MDD;
     MAlpha[1] = MD;
     MAlpha[2] = MZ;
     MAlpha[3] = MI;
     MAlpha[4] = MDI;

}

float min(float a, float b){
      return (a > b) ? b : a;
}

//limitar a theta para -pi ~ pi
//si se pasa pi restarle 2pi
//si se pasa -pi sumarle 2pi
/////////////////////////////////////////////////////////////////
task control(){
     while(true){
	
	float _a_;
	float _xe_;
	float _ye_;
	float a;
	float alpha;
	float _alpha_;
	float _v_;
	float _w_;
	float longitud = 16.2;  //distancia entre ruedas
	
	
	_xe_ = xf-x;
	_ye_ = yf-y;
	_a_ = power(_xe_,2) + power(_ye_,2);

	a = sqrt(_a_);

	_alpha_ = (_ye_ / a);
	alpha = asin(_alpha_) - theta;
	
	//cotrol_difuso
	getDistance(a); //se obtiene MA[]
	getAlpha(alpha); //se obtine MAlpha[]
	
	float acc_coef = 0.0;
	float acc_accion = 0.0;
	float accion_VL = 0.0;
	float coef = 0.0;
	
	for(int i=0;i<4;i++){
	   for(int j=0;j<5;j++){
	      if (MA[i]<MAlpha[j]) coef=MA[i]; else coef=MAlpha[j];
	      //coef = min(MA[i],MAlpha[j]);
	      acc_coef = acc_coef + coef;
	      acc_accion = acc_accion + coef * VL[j][i];
	   }
	}
	
	accion_VL = (acc_accion/acc_coef);
	
	float acc_coef2 = 0;
	float acc_accion2 = 0;
	float coef2 = 0;
	float accion_VR = 0;
	
	for(int i=0;i<4;i++){
	   for(int j=0;j<5;j++){
	      coef2 = min(MA[i],MAlpha[j]);
	      acc_coef2 = acc_coef2 + coef2;
	      acc_accion2 = acc_accion2 + coef2 * VR[j][i];
	   }
	}

	accion_VR = (acc_accion2/acc_coef2);

	float minimo;

	minimo = coef;
	TextOut(0,LCD_LINE8,"MIN:"  + NumToStr(minimo));
	OnFwd(MOTOR_IZQUIERDA, accion_VL);
	OnFwd(MOTOR_DERECHA, accion_VR);
		
	Wait(150);

     }
}

// TASK PARA DIBUJAR EN PANTALLA
task make_draw(){

  int xx;
  int yy;

  //10cm es un pixel

  while(true){
  	
     xx = (x/2) + 50; //50 para iniciar en medio de la pantalla
     yy = (y/2) + 5;  //30 para iniciar en medio de la pantalla
          
     CircleOut(xx,yy,2);
     
  }
}

int us_izquierda = 0;
int us_frente = 0;

task print(){

     SetSensorLowspeed(us_port_izquierda);
     SetSensorLowspeed(us_port_frente);
          
     //true para que siempre se ejecute
     int count = 0;
     while(true){

	if(count==0){
		us_frente = SensorUS(us_port_frente);
		count = count + 1;
	}
	
	if(count==1){
		us_izquierda = SensorUS(us_port_izquierda);
		count = 0;
	}
		
	TextOut(0,LCD_LINE1, "US-IZQ: " + NumToStr(us_izquierda) + "       ");
	TextOut(0,LCD_LINE2, "US-FRE: " + NumToStr(us_frente)    + "       ");
		
	Wait(200);
	
     }
}

/******************************************
 * Seguir objeto encontrado por izquierda
 ******************************************/
task boundary_following(){

     int error; 
     int err_derecha;
     int err_izquierda;
     int pot_a;
     int pot_c;
     
     while(true){

        pot_a = 50;
        pot_c = 50;
        
	//si veo algo
	//while(us_izquierda <= 60){
        
	   //evitar chocar
	   if(us_frente <= 10 || us_izquierda <= 10){
	      //pot_a = 0;
	      //pot_c = 0;
	   }else{
	     
	     if(us_izquierda < 10)
	         err_izquierda = 0;
		
	     if((us_izquierda > 10) && (us_izquierda < 100))
		 err_izquierda = (30 - us_izquierda) * 2;

	     if(us_izquierda > 100)
		 err_izquierda = -10;

	     

	     pot_a = 50+err_izquierda;
	     pot_c = 50-err_izquierda;
		     
	   }
	   
	   //OnFwd(MOTOR_DERECHA,pot_c);
	   //OnFwd(MOTOR_IZQUIERDA,pot_a);

	   //**********************************************
	   //CALCULAR AQUI SI SALIR O NO RESPECTO AL SIGNO
	   //**********************************************

	   // TOMAR LECTURAS DEL ODOMETRO
	   

	//}

	OnFwd(MOTOR_DERECHA,pot_c);
	OnFwd(MOTOR_IZQUIERDA,pot_a);
	
	//Wait(200);
     }

}

task main(){

     Precedes(print,odometria,boundary_following);

}